#!/usr/local/bin/python


kDoNotEditNotice = '// This is a wrapper script created by GMIDL. DO NOT EDIT.'
kImplScriptNotice = """
// The above was generated by GMIDL. Put your code beneath this line."""
        .lstrip('\n')

def writeScriptPrototype(scriptName, argNames=None, argTypes=None,
        returnType=None):
    if not argNames:
        argNames = []
    if not argTypes:
        argTypes = []
    assert len(argNames) == len(argTypes)
    return '///%(scriptName)s(%(args)s%(returnClause)s)' % {
        'scriptName': scriptName,
        'args': ', '.join([
            '%s%s' % (argNames[i], ' ' + argTypes[i] if argTypes[i] else '')
            for i in range(len(argNames))]),
        'returnClause': '; -> %s' % returnType if returnType else ''
    }


_scriptHeaderTemplate = """
/*******************************************************************************
%s
*******************************************************************************/
""".lstrip('\n')
def writeScriptHeader(scriptName,
        description='', longDescription='', returnDescription=''):
    result = scriptName + '\n'
    if description:
        result += '\n%s\n' % description
    if longDescription:
        result += '\n%s\n' % longDescription
    if returnDescription:
        result += '\nReturns: %s\n' % returnDescription
    return _scriptHeaderTemplate % result


def writeImplCall(scriptName, argv='argv', virtual=True):
    if virtual:
        return 'script_execute(__type_lookupMethod__(%(type)s), %(argv)s)' % {
            'type': '__type__(argument0)',
            'argv': argv
        }
    else:
        return '_IMPL_%(scriptName)s(%(argv)s)' % {
            'scriptName': scriptName,
            'argv': argv
        }


_varDeclarationsNonemptyStart = """
// Declare arguments.
var %(argv)s;
// Fill the argument array in reverse order to avoid resizing the array.
""".lstrip('\n')
_varDeclarationsEmpty = '// No arguments.\n'
_varDeclarationTemplate = """
%(argv)s[%(i)d] = argument[%(i)d];
__check_instanceof__(%(argv)s[%(i)d], %(type)s);
""".lstrip('\n')
def writeVariableDeclarations(argv, argTypes):
    result = ''
    if len(argTypes):
        return (_varDeclarationsNonemptyStart % {'argv': argv}
                + '\n'.join([_varDeclarationTemplate % {
                    'argv': argv,
                    'i': arrayIndex,
                    'type': argType,
                } for argType, arrayIndex in reverse(enumerate(argTypes))]))
    else:
        return _varDeclarationsEmpty
    return result


_defaultPrimitiveValues = {
    'any': '0',
    'real': '0',
    'string': '\'\'',
    'array': '0',
    'ds_list': 'ds_list_create()',
    'ds_map': 'ds_map_create()',
    'ds_stack': 'ds_stack_create()',
    'ds_queue': 'ds_queue_create()',
}
def _writeDefaultPropertyValue(propertyType):
    if propertyType in _defaultPrimitiveValues:
        return _defaultPrimitiveValues[propertyType]
    return '%s_create()' % propertyType


_arrayAllocatorTemplate = """
    var newInstance;
    newInstance[__%(className)s_size] = %(className)s;
    newInstance[0] = %(gmidlToken)s;
""".lstrip(' \n')
def writeArrayAllocator(className, propertyNames=None, propertyTypes=None):
    if not propertyNames:
        propertyNames = []
    if not propertyTypes:
        propertyTypes = []
    return _arrayAllocatorTemplate % {
        'className': className
    } + '\t' + '\n\t'.join([
        ('newInstance[__%(className)s_properties_%(propertyName)s] = '
            + '%(value)s;') % {
                'className': className,
                'propertyName': propertyName,
                'value': _writeDefaultPropertyValue(propertyType)
            }
        for propertyName, propertyType in zip(propertyNames, propertyTypes)
    ])


def writeDsMapAllocator():
    raise NotImplementedError


_initializerArgumentsTemplate = """
%(dependencyInjection)s
%(argumentDeclarations)s
"""
def writeInitializerArguments(dependencyNames, dependencyTypes,
        argumentNames, argumentTypes):
    return _initializerArgumentsTemplate % {
        'dependencyInjection': '\n'.join(['']),
        'argumentDeclarations': writeVariableDeclarations(
                argumentNames, argumentTypes)
    }


def writeImplVariableDeclarations(argNames):
    return '\n'.join([
        'var %s = argument0[%d];' % (argName, i)
        for argName, i in enumerate(argNames)])
